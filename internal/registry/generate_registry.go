//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

var output string

func main() {
	_, file, _, ok := runtime.Caller(0)
	if !ok {
		panic("Cannot get path to generate registry")
	}

	dir := filepath.Dir(file)
	fmt.Println("generate_registry.go dir:", dir)

	handlerDir := filepath.Join(dir, "../handler") //  generate_registry.go
	fmt.Println("handler dir:", handlerDir)

	output = filepath.Join(dir, "registry_gen.go")

	constructors := make([]string, 0)

	_ = filepath.Walk(handlerDir, func(path string, info os.FileInfo, err error) error {
		if info == nil || info.IsDir() {
			return nil
		}
		if info.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}
		if strings.HasSuffix(path, "base.go") {
			return nil
		}

		fmt.Println("Scanning:", path) // debug

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			fmt.Println("Parse error:", err)
			return nil
		}

		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && strings.HasPrefix(fn.Name.Name, "New") {
				fmt.Println("Found constructor:", fn.Name.Name) // debug
				constructors = append(constructors, fn.Name.Name)
			}
		}

		return nil
	})

	if len(constructors) == 0 {
		fmt.Println("No constructors found!")
		return
	}

	gen(constructors)
}

func gen(ctors []string) {
	f, _ := os.Create(output)
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by go generate; DO NOT EDIT.\n")
	fmt.Fprintf(f, "package registry\n\nimport \"go-api-scaffold/internal/handler\"\n\nfunc init() {\n")

	for _, c := range ctors {
		fmt.Fprintf(f, "\tRegister(handler.%s)\n", c)
	}

	fmt.Fprintf(f, "}\n")
	fmt.Println("registry_gen.go generated successfully!")
}
